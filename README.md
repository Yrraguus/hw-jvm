>
> public class JvmComprehension {
> 
>     public static void main(String[] args) {
>         int i = 1;                      // 1
>         Object o = new Object();        // 2
>         Integer ii = 2;                 // 3
>         printAll(o, i, ii);             // 4
>         System.out.println("finished"); // 7
>     }
> 
>     private static void printAll(Object o, int i, Integer ii) {
>         Integer uselessVar = 700;                   // 5
>         System.out.println(o.toString() + i + ii);  // 6
>     }
> }

JVM отправляет запрос в подсистему загрузчиков классов
Сначала отрабатывает подсистема загрузчиков классов.
Bootstrap ClassLoader загружает базовые классы.
Application ClassLoader загружает класс JvmComprehension.
Происходит Linking (связывание) - подготовка классов к выполнению (3 этапа: Verify (проверка, что код валиден), Prepare (подготовка примитивов в статических полях), Resolve (связывание ссылок на другие классы)).
Далее классы загружаются в Metaspace.
1. В стэке создаётся фрейм main, в нём создаётся int i со значением 1.
2. Выделяется память в куче, отрабатывает конструктор для Object и переменной o, хранящейся в стэке во фрейме main, ей присваивается ссылка на Object.
3. В куче создаётся объект ii со значением 2.
4. Создаётся фрейм printAll в стэке. В нём будут созданы параметры:
  - o, хранящий ссылку на Object o в куче, 
  - i со значением 1, взятым из фрейма main,
  -  ii, хранящий ссылку на ii в куче.
5. В куче создаётся объект uselessVar со значением 700.
6. В стэке создаётся фрейм toString (в куче создаётся строка со ссылкой на Object), создаётся строка и выводится в консоль: ссылка_на_Object12. Фрейм помечается как закрытый. На переменную uselessVar никто не ссылается, поэтому, если бы после закрытия фрейма printAll был запущен сборщик мусора, этот объект был бы удалён из кучи.
7. В стэке создаётся фрейм со ссылкой на строку "finished" и вывод её в консоль. Фрейм закрывается.

